package de.tudresden.aerospace.contrails.Modeling.Legacy;

/*-
 * #%L
 * RF-Contrails
 * %%
 * Copyright (C) 2024 Institute of Aerospace Engineering, TU Dresden
 * %%
 * Copyright 2,024 Institute of Aerospace Engineering, TU Dresden
 * 
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 * #L%
 */

import de.tudresden.aerospace.contrails.Configuration.XMLParametersLegacy;
import de.tudresden.aerospace.contrails.Modeling.ErrorFunction;
import de.tudresden.aerospace.contrails.Modeling.RePhoton;
import de.tudresden.aerospace.contrails.Modeling.SolarContrail;
import de.tudresden.aerospace.contrails.Modeling.TerrestrialContrail;
import de.tudresden.aerospace.contrails.MonteCarlo.Distribution;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Groups functionality for running Monte Carlo simulations on a contrail's interaction with radiation. This abstract
 * superclass contains common functionality for both the solar and terrestrial radiation parts. To run the MC simulation
 * for a part, initialize an instance of either the {@link SolarContrail} or {@link TerrestrialContrail} subclasses.
 */
public abstract class ContrailLegacy {

    /**
     * Flag to allow random generators to be initialized with a seed
     */
    public boolean deterministicMode = false;

    /**
     * Flag set if an object of the class is shared across threads
     */
    public boolean multiThreadedMode = false;

    /**
     * Delegate holding parameters of the simulation
     */
    protected XMLParametersLegacy params;

    /**
     * The probability distribution generated by the scattering phase function
     */
    protected Distribution scPhFun;

    /**
     * For generating random numbers
     */
    protected Random rand;

    // The following variables cache computation results for better performance
    protected double detsigma;
    protected double hDetsigma;
    protected double c1;
    protected double sqrtPi;

    /**
     * Parameterless constructor to allow subclasses to do their own construction.
     */
    protected ContrailLegacy() {
        this.rand = new Random();
    }

    /**
     * Initializes random with a seed to allow for reproducibility for debugging and testing purposes.
     *
     * @param params The parameters to use in the model.
     * @param randomProvider A custom {@link Random} object that is used for random number generation. Intended for
     *                       testing, e.g. with mock objects.
     */
    public ContrailLegacy(XMLParametersLegacy params, Random randomProvider) {
        this.deterministicMode = true;

        if (randomProvider == null)
            throw new IllegalArgumentException("Random provider cannot be null");

        System.out.println("Warning: operating in deterministic mode. This is for debugging/testing purposes " +
                "and should be disabled when running the simulation properly");

        // Initialize variables
        this.params = params;
        this.rand = randomProvider;
        initialize();

        initializeScPhFun();
    }


    /**
     * Initializes the contrail object with the given parameters.
     *
     * @param params The parameters to use in the model.
     */
    public ContrailLegacy(XMLParametersLegacy params) {
        // Initialize variables
        this.rand = new Random();
        this.params = params;
        initialize();

        initializeScPhFun();
    }

    /**
     * Polymorphic method to allow subclasses to initialize g and other variables before initializing scPhFun.
     */
    protected abstract void initialize();

    /**
     * Creates the scattering phase function object with values calculated from the numSca parameter. Call only in constructor and after initializing {@link ContrailLegacy#params}!
     */
    protected void initializeScPhFun() {
        if (params.getNumSca() == null || params.getG() == null)
            throw new NullPointerException("numSca and g must be set before scattering phase function is initialized");

        // g ... factor of asymmetry
        // n_sca ... number of bins for angle tetha
        // phi is equally distributed
        double d_sca_ang = Math.PI / params.getNumSca();
        double sca_ang[] = new double[params.getNumSca()];
        double sca_p[] = new double[params.getNumSca()];
        for (int i = 0; i < params.getNumSca(); i = i + 1) {
            sca_ang[i] = i * d_sca_ang;
            sca_p[i] = this.scatPhaseFun(params.getG(), i * d_sca_ang);
        }

        this.scPhFun = new Distribution(sca_ang, sca_p);
    }

    /**
     * Getter for the scattering phase function. Intended to provide access to
     * {@link Distribution#setRandomProvider(Random)} for testing.
     *
     * @return The scattering phase function.
     */
    public Distribution getScPhFun() {
        return this.scPhFun;
    }

    /**
     * Implements the Henyey-Greenstein phase function for approximation of radiation scattering by particles.
     *
     * @param g       Factor of asymmetry of the phase function.
     * @param rad_ang Angle of the phase function in radians.
     * @return The approximated value of the phase function.
     * @see <a href="https://ui.adsabs.harvard.edu/link_gateway/1941ApJ....93...70H/doi:10.1086/144246">
     * Diffuse radiation in the Galaxy (Paper)</a> for more details.
     */
    protected double scatPhaseFun(double g, double rad_ang) {
        return (1. - Math.pow(g, 2)) / Math.pow(1. + Math.pow(g, 2) - 2. * g * Math.cos(rad_ang), 1.5);
    }

    /**
     * Helper for {@link #Iextinction(double, double, double, double, double) Iextinction()}, which solves integral
     * {@code 3.76} according to equation {@code 3.77} in <a href="http://dx.doi.org/10.13140/RG.2.2.34522.75206">
     * Optical Properties of Condensation Trails
     * </a>.
     *
     * @param a Coefficient defined in equation {@code 3.72} from the source above.
     * @param b Coefficient defined in equation {@code 3.73} from the source above.
     * @param c Coefficient defined in equation {@code 3.74} from the source above.
     * @param x Positional x-coordinate.
     * @return The solution of integral {@code 3.76}.
     */
    protected double F(double a, double b, double c, double x) {
        double wa = Math.sqrt(a);
        return Math.sqrt(Math.PI) / (2. * wa) * Math.exp(b * b / (4 * a) + c) * ErrorFunction.erf(wa * x - b / (2 * wa));
    }

    /**
     * Calculates the sum of all absorbed and single scattered photons 1-I/I0.
     *
     * @param y0    Positional y-coordinate in the contrail
     * @param z0    Positional z-coordinate in the contrail
     * @param theta Angle to z-coordinate axis (upwards vector). Range: [0, PI]
     * @param phi   Angle to x-coordinate axis (direction of flight). Range: [0, 2*PI]
     * @param s     Distance through contrail traversed to this point.
     * @return Accumulated 1-I/I0 after distance s.
     */
    public double Iextinction(double y0, double z0, double theta, double phi, double s) {
        // 1-I/I0 after distance s through contrail
        double detsigma = params.getSigmaH() * (double) params.getSigmaV() - Math.pow(params.getSigmaS(), 2);

        // a = a' / 2*det(sigma^)
        double a = 1. / (2 * detsigma) * (params.getSigmaV() * Math.pow(Math.sin(theta), 2) * Math.pow(Math.sin(phi), 2)
                - 2 * params.getSigmaS() * Math.sin(theta) * Math.cos(theta) * Math.sin(phi)
                + params.getSigmaH() * Math.pow(Math.cos(theta), 2));
        // b = -b' / 2*det(sigma^)
        double b = -1. / (2 * detsigma) * (2 * (params.getSigmaV() * y0 - params.getSigmaS() * z0) * Math.sin(theta) * Math.sin(phi)
                + 2 * (params.getSigmaH() * z0 - params.getSigmaS() * y0) * Math.cos(theta));
        // c = -c' / 2*det(sigma^)
        double c = -1. / (2 * detsigma) * (params.getSigmaV() * y0 * y0 - 2 * params.getSigmaS() * y0 * z0 + params.getSigmaH() * z0 * z0);
        double C1 = -1. * ((double) params.getAbsorptionFactor() + params.getScatteringFactor()) * params.getDropletRadius() * params.getDropletRadius() * params.getNumIceParticles() / (params.getDistance() * 2 * Math.sqrt(detsigma));

        double Iext = 1 - Math.exp(C1 * (this.F(a, b, c, s) - this.F(a, b, c, 0)));
        return Iext;
    }

    /**
     * Calculates the scattering of a single photon via analytical integration along the flight path. Photons may pass
     * through the contrail without interaction, be scattered once or multiple times or be absorbed. The starting
     * position of the photon as well as whether absorption or scattering occurs is chosen randomly by the MonteCarlo
     * algorithm.
     *
     * @param theta Angle to z-coordinate axis (upwards vector). Range: [0, PI]
     * @param phi   Angle to x-coordinate axis (direction of flight). Range: [0, 2*PI]
     * @return An instance of {@link RePhoton} representing the scattered photon's direction and number of scattering
     * events. If the photon is absorbed, theta and phi are -1.
     */
    public RePhoton singlePhotonIntegration(double theta, double phi) {
        // new algorithm with analytical integration along flight path
        // instead of doing a thousand and one step
        //
        // theta, phi ... where are you from
        // theta = [0,pi]
        // phi = [0,2 pi]
        // x is direction of flight
        // y is perpendicular to x but on flight level
        // z is pointing upwards
        // theta is the angle to z
        // phi is the angle to x

        // for counting scattering events
        int Scat_events = 0;

        // randomly choose starting place along line perpendicular to line starting in
        // center of contrail and going in the chosen direction. +-r_incident in both
        // directions from crosssection
        // Berechnung des Aufpunktes c ----- Aufsetzpunkt = START AM KREISBOGEN
        double yh = Math.sin(theta) * Math.sin(phi);
        double zh = Math.cos(theta);
        double direction = Math.acos(zh / Math.pow(Math.pow(yh, 2) + Math.pow(zh, 2), 0.5));

        // Use ThreadLocalRandom in MT mode for better performance
        double alpha = 0.0;
        if (multiThreadedMode && !deterministicMode) {
            alpha = Math.asin(ThreadLocalRandom.current().nextDouble() * 2 - 1);
        } else {
            alpha = Math.asin(this.rand.nextDouble() * 2 - 1);
        }

        // this is the starting place
        double yPhot = Math.sin(direction - alpha) * params.getIncidentRadius(); //r.incident länge querachse contrail (3sigma)
        double zPhot = Math.cos(direction - alpha) * params.getIncidentRadius(); //alpha winkel zur contrail längsachse S.88

        //hier erhalten theta und phi neue Bedeutung (Wohin geht es)
        theta = Math.PI - theta;
        phi = (phi + Math.PI) % (2 * Math.PI);
        //yPhot=yPhot+this.d*Math.sin(theta)*Math.sin(phi);
        //zPhot=zPhot+this.d*Math.cos(theta);

        double Zs = 0.; // random number determining the distance
        double Zas = 0.; // random number chosing between absorption and scattering.

        // for Nullstellensuche
        double ds0 = 0;
        double ds = 2.01 * params.getIncidentRadius(); // first step width
        double ds1 = 0;
        double fds = 0;
        double fds0 = 0;
        double fds1 = 0;
        double fprime = 0;

        double theta_s = 0.;
        double phi_s = 0.;
        double x_s = 0.;
        double y_s = 0.;
        double z_s = 0.;
        double x_prime = 0.;
        double y_prime = 0.;
        double z_prime = 0.;

        double absorption = params.getAbsorptionFactor() / ((double) params.getAbsorptionFactor() + params.getScatteringFactor());

        // start photon lifetime
        while ((Math.pow(yPhot, 2) + Math.pow(zPhot, 2)) / Math.pow(params.getIncidentRadius(), 2) <= 1.01) {
            // Use ThreadLocalRandom in MT mode for better performance
            if (multiThreadedMode && !deterministicMode) {
                Zs = ThreadLocalRandom.current().nextDouble();
            } else {
                Zs = this.rand.nextDouble();
            }

            // Nullstelle von this.Iextinction(yPhot, zPhot, theta, phi, ds) - Zs;
            ds0 = 0.;
            ds = 2.01 * params.getIncidentRadius(); // first step width
            int in = 0;
            while ((ds - ds0) > 0.01) {
                in = in + 1;
                fds0 = this.Iextinction(yPhot, zPhot, theta, phi, ds0) - Zs;
                fds = this.Iextinction(yPhot, zPhot, theta, phi, ds) - Zs;
                fprime = (fds - fds0) / (ds - ds0);
                ds1 = ds - fds / fprime;
                ds0 = ds;
                ds = ds1;
            }

            // System.out.println("in "+in);
            yPhot = yPhot + ds * Math.sin(theta) * Math.sin(phi);
            zPhot = zPhot + ds * Math.cos(theta);

            if ((Math.pow(yPhot, 2) + Math.pow(zPhot, 2)) / Math.pow(params.getIncidentRadius(), 2) <= 1.01) {
                // Use ThreadLocalRandom in MT mode for better performance
                if (multiThreadedMode && !deterministicMode) {
                    Zas = ThreadLocalRandom.current().nextDouble();
                } else {
                    Zas = this.rand.nextDouble();
                }

                if (Zas < absorption) {
                    return new RePhoton(-1., -1., Scat_events); // -1, -1 as indicator for absorption
                } else {
                    Scat_events = Scat_events + 1;

                    // Use ThreadLocalRandom in MT mode for better performance
                    if (multiThreadedMode && !deterministicMode) {
                        theta_s = this.scPhFun.randomThreadSafe();
                        phi_s = ThreadLocalRandom.current().nextDouble() * 2 * Math.PI;
                    } else {
                        theta_s = this.scPhFun.random(); // randomly scattered according to phase function
                        phi_s = this.rand.nextDouble() * 2 * Math.PI; // phi is equally distributed
                    }

                    x_s = Math.sin(theta_s) * Math.cos(phi_s);
                    y_s = Math.sin(theta_s) * Math.sin(phi_s);
                    z_s = Math.cos(theta_s);
                    // calculate new direction
                    x_prime = (1 - Math.cos(theta)) * (x_s * Math.pow(Math.sin(phi), 2) - y_s * Math.sin(phi) * Math.cos(phi)) + Math.cos(theta) * x_s + Math.sin(theta) * Math.cos(phi) * z_s;
                    y_prime = (1 - Math.cos(theta)) * (y_s * Math.pow(Math.cos(phi), 2) - x_s * Math.sin(phi) * Math.cos(phi)) + Math.cos(theta) * y_s + Math.sin(theta) * Math.sin(phi) * z_s;
                    z_prime = Math.cos(theta) * z_s - Math.sin(theta) * Math.cos(phi) * x_s - Math.sin(theta) * Math.sin(phi) * y_s;
                    // new direction
                    theta = Math.acos(z_prime);
                    if (y_prime > 0) {
                        phi = Math.acos(x_prime / Math.pow(Math.pow(x_prime, 2) + Math.pow(y_prime, 2), 0.5));
                    } else {
                        phi = 2 * Math.PI - Math.acos(x_prime / Math.pow(Math.pow(x_prime, 2) + Math.pow(y_prime, 2), 0.5));
                    }
                }
            }
        }
        return new RePhoton(theta, phi, Scat_events);
    }

    public XMLParametersLegacy getParams() {
        return params;
    }
}
